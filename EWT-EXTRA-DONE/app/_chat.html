<template>
    <main>
        <!-- Chat Window -->
        <div id="chat-window" :class="{ minimized: chatMinimized }">
            <!-- Chat Header with Collapse/Expand button -->
            <div id="chat-header">
                <div class="chat-title">Chat
                    <!-- Notification badge -->
                    <div v-if="unreadMessages > 0" id="notification-badge">{{ unreadMessages }}</div>
                </div>
                <button @click="toggleChat" id="toggle-button">
                    <span v-if="chatMinimized">Expand</span>
                    <span v-else>Minimize</span>
                </button>
            </div>

            <!-- Chat Body -->
            <div id="chat-body" ref="chatBody" v-if="!chatMinimized">
                <!-- Message Section -->
                <section></section>
                <div>
                    <div class="message" 
                         v-for="m of messages" 
                         :class="{ me: m.uid == user.uid }"
                         @mouseover="showActions(m.id)" 
                         @mouseleave="hideActions(m.id)">

                        <!-- Left side for receiver's photo and status -->
                        <div v-if="m.uid !== user.uid" class="profile-container">
                            <img class="photo" :src="getPhotoURL(m.uid)" :title="getDisplayName(m.uid)">
                            <div :class="['online-status', isOnline(m.uid) ? 'online' : 'offline']"></div>
                        </div>

                        <!-- Message Content -->
                        <div class="message-content" :class="{ 'from-me': m.uid == user.uid }">
                            <small>{{ getDisplayName(m.uid) }}</small>

                            <!-- Normal Text Message (not deleted) -->
                            <template v-if="m.type == 'text' && !m.deleted">
                                <div v-html="format(m.text)"></div>
                                <small v-if="m.edited">(edited)</small>
                            </template>

                            <!-- Deleted Message -->
                            <template v-if="m.deleted">
                                <div>This message was deleted</div>
                            </template>

                            <!-- Image Message -->
                            <template v-if="m.type == 'image'">
                                <img class="image" @click="fullscreen" :src="m.url">
                            </template>

                            <!-- File Message -->
                            <template v-if="m.type == 'file'">
                                <a :href="m.url" download>{{ m.filename }}</a>
                            </template>

                            <!-- Edit and Delete Buttons (only for own non-deleted messages) -->
                            <div v-if="!m.deleted && m.showActions && m.uid == user.uid" class="actions">
                                <button @click="editMessage(m)">Edit</button>
                                <button @click="deleteMessage(m)">Delete</button>
                            </div>

                            <!-- Timestamps: Show the correct timestamp based on message status -->
                            <template v-if="m.deleted">
                                <!-- Show only delete timestamp for deleted messages -->
                                <small>{{ m.deleteTimestamp?.toDate().toLocaleTimeString() ?? '...' }}</small>
                            </template>

                            <template v-else-if="m.edited">
                                <!-- Show only edit timestamp for edited messages -->
                                <small>{{ m.editTimestamp?.toDate().toLocaleTimeString() ?? '...' }}</small>
                            </template>

                            <template v-else>
                                <!-- Show sent timestamp for normal messages -->
                                <small>{{ m.timestamp ? m.timestamp.toDate().toLocaleTimeString() : '...' }}</small>
                            </template>
                        </div>

                        <!-- Right side for sender's photo and status -->
                        <div v-if="m.uid == user.uid" class="profile-container">
                            <img class="photo me" :src="getPhotoURL(m.uid)" :title="getDisplayName(m.uid)">
                            <div :class="['online-status', isOnline(m.uid) ? 'online' : 'offline']"></div>
                        </div>
                    </div>
                </div>

                <!-- Form: For sending new messages -->
                <form id="form" autocomplete="off">
                    <input id="text" v-model.trim="text" v-focus>
                    <div class="send-options">
                        <button @click.prevent="send" :disabled="!text">Send</button>

                        <button type="button" @click="$refs.image.click()">Image</button>
                        <input type="file" multiple hidden accept="image/*" ref="image" @change="imageChange">

                        <button type="button" @click="$refs.file.click()">File</button>
                        <input type="file" multiple hidden ref="file" @change="fileChange">
                    </div>
                </form>
            </div>

            <!-- Sound notification -->
            <audio ref="notificationSound" src="https://www.soundjay.com/button/beep-07.wav" preload="auto"></audio>
        </div>
    </main>
</template>

<script>
    let unsubUsers = null;
    let unsubMessages = null;
    let userRef = null;
    let statusRef = null;
    let onlineRef = null;

    app.component({
        data: () => ({
            user: null,
            users: [],
            online: {},
            text: '',
            messages: [],
            unreadMessages: 0,   // Track unread messages count
            chatMinimized: false,  // Track chat state (minimized or not)
        }),

        methods: {
            toggleChat() {
                this.chatMinimized = !this.chatMinimized;
                if (!this.chatMinimized) {
                    this.unreadMessages = 0;
                }
            },

            showActions(messageId) {
                const message = this.messages.find(m => m.id === messageId);
                if (message && message.uid === this.user.uid && !message.deleted) {
                    message.showActions = true;
                }
            },

            hideActions(messageId) {
                const message = this.messages.find(m => m.id === messageId);
                if (message) {
                    message.showActions = false;
                }
            },

            send() {
                if (this.text) {
                    const tempTimestamp = new Date();  // Local timestamp for immediate display

                    // Temporary message for sender's immediate view
                    const tempMessage = {
                        id: Date.now().toString(), // Temporary unique ID until Firestore returns the real ID
                        type: 'text',
                        text: this.text,
                        uid: this.user.uid,
                        timestamp: tempTimestamp,  // Local timestamp
                        showActions: false, // Initializing showActions
                        temp: true,  // Mark this as a temporary message
                    };

                    // Add the temporary message to the sender's view
                    this.messages.push(tempMessage);

                    // Scroll to the bottom after sending
                    this.scrollToBottom();

                    // Send the message to Firestore
                    const docRef = MESSAGES.doc();
                    docRef.set({
                        type: 'text',
                        text: this.text,
                        uid: this.user.uid,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),  // Server timestamp
                        showActions: false,  // Adding showActions field to Firestore message
                    }).then(() => {
                        console.log("Message successfully sent");
                    }).catch(error => {
                        console.error("Error sending message: ", error);
                    });

                    // Clear the input field
                    this.text = '';
                }
            },

            // Automatically scroll to the bottom of the chat
            scrollToBottom() {
                this.$nextTick(() => {
                    const chatBody = this.$refs.chatBody;
                    chatBody.scrollTop = chatBody.scrollHeight;
                });
            },

            // Handle image file uploads
            imageChange(e) {
                const files = e.target.files;
                for (const f of files) {
                    fit(f, 1000, 1000, 'blob', 'image/webp')
                        .then(blob => {
                            const doc = MESSAGES.doc();
                            STORAGE.ref('files').child(doc.id + '.webp')
                                .put(blob)
                                .then(snap => snap.ref.getDownloadURL())
                                .then(url => {
                                    doc.set({
                                        type: 'image',
                                        url,
                                        uid: this.user.uid,
                                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                                        showActions: false,  // Initializing showActions for image message
                                    });
                                });
                        });
                }
                e.target.value = '';
            },

            // Handle general file uploads
            fileChange(e) {
                const files = e.target.files;
                for (const f of files) {
                    const doc = MESSAGES.doc();
                    const ext = f.name.split('.').pop();
                    const metadata = {
                        contentDisposition: `attachment; filename="${f.name}"`,
                    };
                    STORAGE.ref('files').child(doc.id + '.' + ext)
                        .put(f, metadata)
                        .then(snap => snap.ref.getDownloadURL())
                        .then(url => {
                            doc.set({
                                type: 'file',
                                url,
                                filename: f.name,
                                uid: this.user.uid,
                                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                                showActions: false,  // Initializing showActions for file message
                            });
                        });
                }
                e.target.value = '';
            },

            // Edit a message
            editMessage(message) {
                const newText = prompt("Edit your message:", message.text);
                if (newText !== null && newText !== message.text) {
                    const doc = MESSAGES.doc(message.id);
                    doc.update({
                        text: newText,
                        edited: true,
                        editTimestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    }).then(() => {
                        console.log("Message successfully edited");
                    }).catch(error => {
                        console.error("Error editing message: ", error);
                    });
                }
            },

            // Delete a message
            deleteMessage(message) {
                if (confirm("Are you sure you want to delete this message?")) {
                    const doc = MESSAGES.doc(message.id);
                    doc.update({
                        deleted: true,
                        deleteTimestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    }).then(() => {
                        console.log("Message successfully deleted");
                    }).catch(error => {
                        console.error("Error deleting message: ", error);
                    });
                }
            },

            // Get user's photoURL
            getPhotoURL(uid) {
                return this.users.find(u => u.uid == uid)?.photoURL;
            },

            // Get user's displayName
            getDisplayName(uid) {
                return this.users.find(u => u.uid == uid)?.displayName;
            },

            // Check if a user is online
            isOnline(uid) {
                return this.online[uid] === true;
            },

            // Format text safely to prevent XSS
            format(text) {
                text = $('<div>').text(text).html();
                return text;
            },

            // Play notification sound
            playNotificationSound() {
                this.$refs.notificationSound.play().catch(() => {
                    console.log('Audio autoplay issue, user interaction needed');
                });
            },
        },

        async created() {
            function getUser() {
                return new Promise(resolve => {
                    const unsub = AUTH.onAuthStateChanged(user => {
                        unsub();
                        resolve(user);
                    });
                });
            }

            this.user = await getUser();

            if (!this.user) {
                this.$router.push('/sign-in');
                return;
            }

            document.title = 'Firebase Chat : Protected';

            // Firestore --> Handle users
            unsubUsers = USERS
                .orderBy('displayName')
                .onSnapshot(snap => {
                    this.users = [];
                    snap.forEach(doc => {
                        this.users.push({ uid: doc.id, ...doc.data() });
                    });
                });

            // Realtime DB --> Handle online status
            const db = firebase.database();
            userRef = db.ref(this.user.uid);
            statusRef = db.ref('.info/connected');
            onlineRef = db.ref();

            statusRef.on('value', snap => {
                userRef.onDisconnect().remove();
                userRef.set(true);
            });

            onlineRef.on('value', snap => {
                this.online = snap.val();
            });

            // Firestore --> Handle messages
            unsubMessages = MESSAGES
                .orderBy('timestamp')
                .limitToLast(10)
                .onSnapshot(snap => {
                    snap.docChanges().forEach(change => {
                        const { type, doc } = change;
                        const messageData = { id: doc.id, ...doc.data() };

                        if (type === 'added') {
                            const existingIndex = this.messages.findIndex(m => m.temp && m.text === messageData.text && m.uid === this.user.uid);
                            if (existingIndex !== -1) {
                                this.messages[existingIndex] = messageData;
                            } else {
                                messageData.showActions = false;  // Add showActions for new messages
                                this.messages.push(messageData);
                            }
                            if (messageData.uid !== this.user.uid) {
                                this.playNotificationSound();
                                if (this.chatMinimized) {
                                    this.unreadMessages += 1;
                                }
                            }
                            this.scrollToBottom();
                        } else if (type === 'modified') {
                            const index = this.messages.findIndex(m => m.id === doc.id);
                            if (index !== -1) {
                                this.messages[index] = messageData;
                            }
                        } else if (type === 'removed') {
                            const index = this.messages.findIndex(m => m.id === doc.id);
                            if (index !== -1) {
                                this.messages.splice(index, 1);
                            }
                        }
                    });
                });
        },

        unmounted() {
            unsubUsers?.();
            unsubMessages?.();
            userRef?.remove();
            userRef?.off();
            statusRef?.off();
            onlineRef?.off();
        },
    });
</script>

<!-- Styles for Chat UI -->
<style>
    #chat-window {
    width: 300px;
    border: 1px solid #666;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    position: fixed;
    bottom: 20px;
    right: 20px;
    background-color: white;
}

#chat-header {
    background-color: #FF9800;
    color: white;
    padding: 10px;
    display: flex;
    justify-content: space-between;
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
    align-items: center;
}

#chat-header .chat-title {
    font-weight: bold;
    display: flex;
    align-items: center;
    gap: 5px;
}

#notification-badge {
    background-color: red;
    color: white;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    margin-left: 5px;
}

#toggle-button {
    background: none;
    border: none;
    color: white;
    cursor: pointer;
}

#chat-body {
    padding: 10px;
    max-height: 400px;
    overflow-y: auto;
}

.message {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
}

.message-content {
    background-color: #E0F7FA;
    border-radius: 15px;
    padding: 10px;
    max-width: 200px;
    font-size: 14px;
}

.me {
    justify-content: right;
}

.from-me {
    background-color: #B3E5FC;
    margin-left: auto;
}

.message-content.from-me {
    background-color: #B3E5FC;
}

.photo {
    width: 40px;  /* Slightly increased size */
    height: 40px;
    border: 2px solid #666;
    border-radius: 50%;
    position: relative;
    object-fit: cover;
}

.image {
    max-width: 200px;
    max-height: 200px;
    border: 1px solid #666;
    cursor: pointer;
}

.profile-container {
    position: relative;
    display: inline-block;
}

.online-status {
    position: absolute;
    width: 12px;  /* Slightly increased size */
    height: 12px;
    border-radius: 50%;
    border: 2px solid white;
    bottom: 0;
    right: 0;  /* Adjusted positioning for better alignment */
}

.online-status.online {
    background-color: green;
}

.online-status.offline {
    background-color: grey;
}

#form {
    display: flex;
    padding: 10px;
    border-top: 1px solid #ddd;
    flex-direction: column;
}

#form input {
    flex: 1;
    border-radius: 20px;
    border: 1px solid #ccc;
    padding: 10px;
}

.send-options {
    display: flex;
    justify-content: space-between;
    margin-top: 5px;
}

.send-options button {
    background-color: #FF9800;
    border: none;
    color: white;
    padding: 10px;
    border-radius: 20px;
    cursor: pointer;
    width: 80px;
}

.minimized #chat-body,
.minimized #form {
    display: none;
}

/* Ensuring correct positioning for sender and receiver */
.message .photo.me {
    margin-left: 10px;
}

.message .photo {
    margin-right: 10px;
}

/* Add spacing between the profile image and message content */
.message .profile-container {
    margin-right: 10px;
}

.message.me .profile-container {
    margin-left: 10px;
    margin-right: 0;
}

</style>
